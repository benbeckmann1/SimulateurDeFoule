import java.awt.*;

public class Agent {
    private int x; // Coordonnée x du centre du cercle noir
    private int y; // Coordonnée y du centre du cercle noir
    private int tailleAgent; // Taille du cercle noir

    public Agent(int x, int y, int tailleAgent) {
        this.x = x;
        this.y = y;
        this.tailleAgent = tailleAgent;
    }

    public void paintComponent(Graphics g) {
        g.setColor(Color.BLACK);
        g.fillOval(x - tailleAgent / 2, y - tailleAgent / 2, tailleAgent, tailleAgent);
    }

    // Getters et setters pour les attributs x, y et tailleAgent
    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getTailleAgent() {
        return tailleAgent;
    }

    public void setTailleAgent(int tailleAgent) {
        this.tailleAgent = tailleAgent;
    }
}


import java.awt.*;

public class Sortie {
    private int tailleSortie;
    private int x; // Coordonnée x du cercle rouge
    private int y; // Coordonnée y du cercle rouge

    public Sortie(int taille, int x, int y) {
        this.tailleSortie = taille;
        this.x = x;
        this.y = y;
    }

    public void paintComponent(Graphics g) {
        g.setColor(Color.RED);
        g.fillOval(x, y, tailleSortie, tailleSortie);
    }

    // Getters et setters pour les attributs x et y
    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getTaille() {
        return this.tailleSortie;
    }
}

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Cercle rouge représenté par la classe Sortie
    private Agent agent; // Cercle noir représenté par la classe Agent

    public CercleAnimation() {
        sortie = new Sortie(60, 400, 300); // Crée un objet Sortie avec une taille de 200 pixels et les coordonnées x=150, y=150
        agent = new Agent(0, 0, 26); // Crée un objet Agent avec une taille de 26 pixels et les coordonnées x=0, y=0
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        sortie.paintComponent(g); // Dessine le cercle rouge à l'aide de la classe Sortie
        agent.paintComponent(g); // Dessine le cercle noir à l'aide de la classe Agent
    }

    public void animate() {
        // Animation pour déplacer le cercle noir vers le centre du cercle rouge
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // Calcule la nouvelle position du cercle noir
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                if (agent.getX() < targetX) {
                    agent.setX(agent.getX() + 1);
                } else if (agent.getX() > targetX) {
                    agent.setX(agent.getX() - 1);
                }

                if (agent.getY() < targetY) {
                    agent.setY(agent.getY() + 1);
                } else if (agent.getY() > targetY) {
                    agent.setY(agent.getY() - 1);
                }

                // Redessine la fenêtre pour mettre à jour l'animation
                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(500, 500);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}


VERSION COOL :

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Cercle rouge représenté par la classe Sortie
    private Agent agent; // Cercle noir représenté par la classe Agent

    public CercleAnimation() {
        sortie = new Sortie(60, 400, 300); // Crée un objet Sortie avec une taille de 200 pixels et les coordonnées x=150, y=150
        agent = new Agent(0, 0, 26); // Crée un objet Agent avec une taille de 26 pixels et les coordonnées x=0, y=0
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        sortie.paintComponent(g); // Dessine le cercle rouge à l'aide de la classe Sortie
        agent.paintComponent(g); // Dessine le cercle noir à l'aide de la classe Agent
    }

    public void animate() {
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                int deltaX = targetX - agent.getX(); // Calcul du déplacement en x
                int deltaY = targetY - agent.getY(); // Calcul du déplacement en y

                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // Calcul de la distance entre les deux points

                // Calcul du déplacement proportionnel à la distance
                double ratio = 0; // Facteur d'échelle pour la distance
                if (distance > 0) {
                    ratio = Math.min(1.0, 5.0 / distance); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                }

                int stepX = (int) (deltaX * ratio); // Déplacement en x proportionnel à la distance
                int stepY = (int) (deltaY * ratio); // Déplacement en y proportionnel à la distance

                agent.setX(agent.getX() + stepX); // Mise à jour de la position x du cercle noir
                agent.setY(agent.getY() + stepY); // Mise à jour de la position y du cercle noir

                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(500, 500);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}



VERSION 3 :



import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Cercle rouge représenté par la classe Sortie
    private Agent agent; // Cercle noir représenté par la classe Agent

    public CercleAnimation() {
        sortie = new Sortie(300, 400, 60); // Crée un objet Sortie avec une taille de 200 pixels et les coordonnées x=150, y=150
        agent = new Agent(0, 0, 26); // Crée un objet Agent avec une taille de 26 pixels et les coordonnées x=0, y=0
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        sortie.paintComponent(g); // Dessine le cercle rouge à l'aide de la classe Sortie
        agent.paintComponent(g); // Dessine le cercle noir à l'aide de la classe Agent
    }

    public void animate() {
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                int deltaX = targetX - agent.getX(); // Calcul du déplacement en x
                int deltaY = targetY - agent.getY(); // Calcul du déplacement en y

                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // Calcul de la distance entre les deux points

                // Calcul du déplacement proportionnel à la distance
                double ratio = 0; // Facteur d'échelle pour la distance
                if (distance > 0) {
                    ratio = Math.min(1.0, 5.0 / distance); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                }

                int stepX = (int) (deltaX * ratio); // Déplacement en x proportionnel à la distance
                int stepY = (int) (deltaY * ratio); // Déplacement en y proportionnel à la distance

                agent.setX(agent.getX() + stepX); // Mise à jour de la position x du cercle noir
                agent.setY(agent.getY() + stepY); // Mise à jour de la position y du cercle noir

                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(500, 500);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}

import java.awt.*;

public class Sortie {
    private int tailleSortie;
    private int x; // Coordonnée x du cercle rouge
    private int y; // Coordonnée y du cercle rouge

    public Sortie(int x, int y, int taille) {
        this.tailleSortie = taille;
        this.x = x;
        this.y = y;
    }

    public void paintComponent(Graphics g) {
        g.setColor(Color.RED);
        g.fillOval(x, y, tailleSortie, tailleSortie);
    }

    // Getters et setters pour les attributs x et y
    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getTaille() {
        return this.tailleSortie;
    }
}


import java.awt.*;

public class Agent {
    private int x; // Coordonnée x du centre du cercle noir
    private int y; // Coordonnée y du centre du cercle noir
    private int tailleAgent; // Taille du cercle noir

    public Agent(int x, int y, int tailleAgent) {
        this.x = x;
        this.y = y;
        this.tailleAgent = tailleAgent;
    }

    public void paintComponent(Graphics g) {
        g.setColor(Color.BLACK);
        g.fillOval(x - tailleAgent / 2, y - tailleAgent / 2, tailleAgent, tailleAgent);
    }

    // Getters et setters pour les attributs x, y et tailleAgent
    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getTailleAgent() {
        return tailleAgent;
    }

    public void setTailleAgent(int tailleAgent) {
        this.tailleAgent = tailleAgent;
    }
    
    public int getXMilieu() {
    	return getX() + getTailleAgent() / 2;
    }
    
    public int getYMilieu() {
    	return getY() + getTailleAgent() / 2;
    }
}


import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;

public class Mur {
    private int x1, y1, x2, y2;

    public Mur(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    
    public double tailleMur() {
    	return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    public int getX1() {
        return x1;
    }

    public int getY1() {
        return y1;
    }

    public int getX2() {
        return x2;
    }

    public int getY2() {
        return y2;
    }

    public Shape getHitbox() {
        int centerX = (x1 + x2) / 2;
        int centerY = (y1 + y2) / 2;
        int width = 3 * (int) tailleMur() / 2;
        int height = (int) tailleMur() / 2;
        Ellipse2D ellipse = new Ellipse2D.Double(centerX - width / 2, centerY - height / 2, width, height);
        double angle = Math.atan2(y2 - y1, x2 - x1);
        AffineTransform transform = AffineTransform.getRotateInstance(angle, centerX, centerY);
        Shape transformedEllipse = transform.createTransformedShape(ellipse);
        return transformedEllipse;
    }

}

VERSION MUR CREE :

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Cercle rouge représenté par la classe Sortie
    private Agent agent; // Cercle noir représenté par la classe Agent
    private Mur mur; // Création d'un mur diagonal

    public CercleAnimation() {
        sortie = new Sortie(300, 400, 60); // Crée un objet Sortie avec une taille de 200 pixels et les coordonnées x=150, y=150
        agent = new Agent(0, 0, 26); // Crée un objet Agent avec une taille de 26 pixels et les coordonnées x=0, y=0
        mur = new Mur(50, 300, 400, 50); // Crée un objet Mur avec les coordonnées x1=200, y1=100 et x2=400, y2=300
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        mur.paintComponent(g);
        sortie.paintComponent(g); // Dessine le cercle rouge à l'aide de la classe Sortie
        agent.paintComponent(g); // Dessine le cercle noir à l'aide de la classe Agent
    }

    public void animate() {
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                int deltaX = targetX - agent.getX(); // Calcul du déplacement en x
                int deltaY = targetY - agent.getY(); // Calcul du déplacement en y

                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // Calcul de la distance entre les deux points

                // Calcul du déplacement proportionnel à la distance
                double ratio = 0; // Facteur d'échelle pour la distance
                if (distance > 0) {
                    ratio = Math.min(1.0, 5.0 / distance); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                }

                int stepX = (int) (deltaX * ratio); // Déplacement en x proportionnel à la distance
                int stepY = (int) (deltaY * ratio); // Déplacement en y proportionnel à la distance

                agent.setX(agent.getX() + stepX); // Mise à jour de la position x du cercle noir
                agent.setY(agent.getY() + stepY); // Mise à jour de la position y du cercle noir

                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(500, 500);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}

VERSION 4 :

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Sortie représentée par un cercle rouge
    private Agent agent; // Agent représenté par un cercle noir
    private Mur mur; // Création d'un mur diagonal

    public CercleAnimation() {
        sortie = new Sortie(300, 400, 60); // Crée une sortie
        agent = new Agent(0, 0, 26); // Crée un agent
        mur = new Mur(150, 350, 250, 100); // Crée un mur
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        mur.paintComponent(g);
        mur.paintHitbox(g);
        sortie.paintComponent(g);
        agent.paintComponent(g);
        agent.paintCollisionEllipse(g);
    }

    public void animate() {
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                int deltaX = targetX - agent.getX(); // Calcul du déplacement en x
                int deltaY = targetY - agent.getY(); // Calcul du déplacement en y

                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // Calcul de la distance entre les deux points

                // Calcul du déplacement proportionnel à la distance
                double ratio = 0; // Facteur d'échelle pour la distance
                if (distance > 0) {
                    ratio = Math.min(1.0, 5.0 / distance); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                }

                int stepX = (int) (deltaX * ratio); // Déplacement en x proportionnel à la distance
                int stepY = (int) (deltaY * ratio); // Déplacement en y proportionnel à la distance

                // Vérifie si la nouvelle position de l'agent est à l'intérieur du mur
                if (agent.tropProche(mur.getHitbox())) {
                    stepX = 0;
                    stepY = 0;
                }

                agent.setX(agent.getX() + stepX); // Mise à jour de la position x du cercle noir
                agent.setY(agent.getY() + stepY); // Mise à jour de la position y du cercle noir

                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(500, 500);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}

import java.awt.*;
import java.awt.geom.Ellipse2D;

public class Agent {
    private int x; // Coordonnée x du centre du cercle noir
    private int y; // Coordonnée y du centre du cercle noir
    private int tailleAgent; // Taille du cercle noir

    public Agent(int x, int y, int tailleAgent) {
        this.x = x;
        this.y = y;
        this.tailleAgent = tailleAgent;
    }

    public void paintComponent(Graphics g) {
        g.setColor(Color.BLACK);
        g.fillOval(x - tailleAgent / 2, y - tailleAgent / 2, tailleAgent, tailleAgent);
    }

    // Getters et setters pour les attributs x, y et tailleAgent
    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getTailleAgent() {
        return tailleAgent;
    }

    public void setTailleAgent(int tailleAgent) {
        this.tailleAgent = tailleAgent;
    }
    
    public int getXMilieu() {
    	return getX() + getTailleAgent() / 2;
    }
    
    public int getYMilieu() {
    	return getY() + getTailleAgent() / 2;
    }
    
    public Ellipse2D getCollisionEllipse() {
        return new Ellipse2D.Double(x - tailleAgent / 2, y - tailleAgent / 2, tailleAgent, tailleAgent);
    }
    
    public void paintCollisionEllipse(Graphics g) {
        Graphics2D g2d = (Graphics2D) g;
        g2d.setColor(Color.RED);
        Ellipse2D ellipse = getCollisionEllipse();
        g2d.draw(ellipse);
    }
    
    public double[] getPointsX() {
        double[] pointsX = new double[360];
        for(int i = 0; i < 360; i++) {
            double rad = Math.toRadians(i);
            double x = getX() + (getTailleAgent() / 2.0) * Math.cos(rad);
            pointsX[i] = x;
        }
        return pointsX;
    }

    public double[] getPointsY() {
        double[] pointsY = new double[360];
        for(int i = 0; i < 360; i++) {
            double rad = Math.toRadians(i);
            double y = getY() + (getTailleAgent() / 2.0) * Math.sin(rad);
            pointsY[i] = y;
        }
        return pointsY;
    }

    public boolean tropProche(Shape hitbox) {
    	double[] pointsX = getPointsX();
    	double[] pointsY = getPointsY();
    	for (int i = 0; i < 4; i++) {
            if (hitbox.contains(pointsX[i], pointsY[i])) {
                return true;
            }
        }
        return false;
    }

}

import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;

public class Mur {
    private int x1, y1, x2, y2;

    public Mur(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    
    public double tailleMur() {
    	return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    public int getX1() {
        return x1;
    }

    public int getY1() {
        return y1;
    }

    public int getX2() {
        return x2;
    }

    public int getY2() {
        return y2;
    }

    public Shape getHitbox() {
        int centerX = (x1 + x2) / 2;
        int centerY = (y1 + y2) / 2;
        int width = 3 * (int) tailleMur() / 2;
        int height = (int) tailleMur() / 2;
        Ellipse2D ellipse = new Ellipse2D.Double(centerX - width / 2, centerY - height / 2, width, height);
        double angle = Math.atan2(y2 - y1, x2 - x1);
        AffineTransform transform = AffineTransform.getRotateInstance(angle, centerX, centerY);
        Shape transformedEllipse = transform.createTransformedShape(ellipse);
        return transformedEllipse;
    }
    
    public void paintHitbox(Graphics g) {
        Shape hitbox = getHitbox();
        g.setColor(Color.RED);
        Graphics2D g2d = (Graphics2D) g;
        g2d.draw(hitbox);
    }

	public void paintComponent(Graphics g) {
		g.setColor(Color.BLUE);
        g.drawLine(x1, y1, x2, y2);;
	}

}

VERSION BRUH :

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Sortie représentée par un cercle rouge
    private Agent agent; // Agent représenté par un cercle noir
    private Mur mur; // Création d'un mur diagonal

    public CercleAnimation() {
        sortie = new Sortie(300, 400, 60); // Crée une sortie
        agent = new Agent(0, 0, 26); // Crée un agent
        mur = new Mur(70, 300, 180, 70); // Crée un mur
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        mur.paintComponent(g);
        mur.paintHitbox(g);
        sortie.paintComponent(g);
        agent.paintComponent(g);
        agent.paintCollisionEllipse(g);
    }

    public void animate() {
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                int deltaX = targetX - agent.getX(); // Calcul du déplacement en x
                int deltaY = targetY - agent.getY(); // Calcul du déplacement en y

                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // Calcul de la distance entre les deux points

                // Calcul du déplacement proportionnel à la distance
                double ratio = 0; // Facteur d'échelle pour la distance
                if (distance > 0) {
                    ratio = Math.min(1.0, 5.0 / distance); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                }

                int stepX = (int) (deltaX * ratio); // Déplacement en x proportionnel à la distance
                int stepY = (int) (deltaY * ratio); // Déplacement en y proportionnel à la distance

             // Vérifie si la nouvelle position de l'agent est à l'intérieur du mur
                if (agent.tropProche(mur.getHitbox())) {
                    int nearestX, nearestY;

                    // Calcul de la distance entre l'agent et l'extrémité gauche du mur
                    int distanceToLeft = (int) Math.sqrt(Math.pow(agent.getX() - mur.getX1(), 2) + Math.pow(agent.getY() - mur.getX1(), 2));

                    // Calcul de la distance entre l'agent et l'extrémité droite du mur
                    int distanceToRight = (int) Math.sqrt(Math.pow(agent.getX() - mur.getX2(), 2) + Math.pow(agent.getY() - mur.getX1(), 2));

                    // Choix de l'extrémité la plus proche
                    if (distanceToLeft < distanceToRight) {
                        nearestX = mur.getX1();
                        nearestY = mur.getY1();
                    } else {
                        nearestX = mur.getX2();
                        nearestY = mur.getY2();
                    }

                    // Calcul du déplacement vers l'extrémité la plus proche
                    int deltaNearestX = nearestX - agent.getX();
                    int deltaNearestY = nearestY - agent.getY();

                    double distanceToNearest = Math.sqrt(deltaNearestX * deltaNearestX + deltaNearestY * deltaNearestY); // Calcul de la distance entre l'agent et l'extrémité la plus proche

                    double ratioToNearest = 0; // Facteur d'échelle pour la distance vers l'extrémité la plus proche
                    if (distanceToNearest > 0) {
                        ratioToNearest = Math.min(1.0, 5.0 / distanceToNearest); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                    }

                    int stepNearestX = (int) (deltaNearestX * ratioToNearest); // Déplacement en x proportionnel à la distance vers l'extrémité la plus proche
                    int stepNearestY = (int) (deltaNearestY * ratioToNearest); // Déplacement en y proportionnel à la distance vers l'extrémité la plus proche

                    agent.setX(agent.getX() + stepNearestX); // Mise à jour de la position x du cercle noir
                    agent.setY(agent.getY() + stepNearestY); // Mise à jour de la position y du cercle noir
                }


                agent.setX(agent.getX() + stepX); // Mise à jour de la position x du cercle noir
                agent.setY(agent.getY() + stepY); // Mise à jour de la position y du cercle noir

                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(500, 500);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}


VERSION LOSANGE HITBOX :

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class CercleAnimation extends JPanel {
    private Sortie sortie; // Sortie représentée par un cercle rouge
    private Agent agent; // Agent représenté par un cercle noir
    private Mur mur; // Création d'un mur diagonal

    public CercleAnimation() {
        sortie = new Sortie(450, 600, 60); // Crée une sortie
        agent = new Agent(0, 0, 26); // Crée un agent
        mur = new Mur(250, 500, 500, 100); // Crée un mur
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        mur.paintComponent(g);
        mur.paintHitbox(g);
        sortie.paintComponent(g);
        agent.paintComponent(g);
        agent.paintCollisionEllipse(g);
    }

    public void animate() {
        Timer timer = new Timer(10, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int targetX = sortie.getX() + sortie.getTaille() / 2; // Coordonnée x du centre du cercle rouge
                int targetY = sortie.getY() + sortie.getTaille() / 2; // Coordonnée y du centre du cercle rouge

                int deltaX = targetX - agent.getX(); // Calcul du déplacement en x
                int deltaY = targetY - agent.getY(); // Calcul du déplacement en y

                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // Calcul de la distance entre les deux points

                // Calcul du déplacement proportionnel à la distance
                double ratio = 0; // Facteur d'échelle pour la distance
                if (distance > 0) {
                    ratio = Math.min(1.0, 5.0 / distance); // On limite le facteur d'échelle à 1 et on utilise un facteur d'échelle maximum de 5 pour éviter des déplacements trop rapides
                }

                int stepX = (int) (deltaX * ratio); // Déplacement en x proportionnel à la distance
                int stepY = (int) (deltaY * ratio); // Déplacement en y proportionnel à la distance

             // Vérifie si la nouvelle position de l'agent est à l'intérieur du mur
                if (agent.tropProche(mur.getHitbox())) {
                    stepX = 0;
                    stepY = 0;
                }


                agent.setX(agent.getX() + stepX); // Mise à jour de la position x du cercle noir
                agent.setY(agent.getY() + stepY); // Mise à jour de la position y du cercle noir

                repaint();

                // Arrête l'animation lorsque le cercle noir atteint le centre du cercle rouge
                if (agent.getX() == targetX && agent.getY() == targetY) {
                    ((Timer) e.getSource()).stop();
                }
            }
        });
        timer.start();
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Cercle Animation");
        CercleAnimation cercleAnimation = new CercleAnimation();
        frame.add(cercleAnimation);
        frame.setSize(800, 800);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);

        cercleAnimation.animate();
    }
}

import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;

public class Mur {
    private int x1, y1, x2, y2;

    public Mur(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    
    public double getTaille() {
    	return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    public int getX1() {
        return x1;
    }

    public int getY1() {
        return y1;
    }

    public int getX2() {
        return x2;
    }

    public int getY2() {
        return y2;
    }

    public Shape getHitbox() {
        int centerX = (x1 + x2) / 2;
        int centerY = (y1 + y2) / 2;
        int width = (int) getTaille() / 2;
        int height = width;
        Path2D.Double path = new Path2D.Double();
        path.moveTo(centerX, centerY - height);
        path.lineTo(centerX + width, centerY);
        path.lineTo(centerX, centerY + height);
        path.lineTo(centerX - width, centerY);
        path.closePath();
        double angle = Math.atan2(y2 - y1, x2 - x1);
        AffineTransform transform = AffineTransform.getRotateInstance(angle, centerX, centerY);
        Shape transformedPath = transform.createTransformedShape(path);
        return transformedPath;
    }

    
    public void paintHitbox(Graphics g) {
        Shape hitbox = getHitbox();
        g.setColor(Color.RED);
        Graphics2D g2d = (Graphics2D) g;
        g2d.draw(hitbox);
    }

	public void paintComponent(Graphics g) {
		g.setColor(Color.BLUE);
        g.drawLine(x1, y1, x2, y2);;
	}

}

